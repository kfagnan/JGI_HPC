\documentclass{article}
\begin{document}
UPC Study Group Homework\\
For these experiments, wen will use the CrayPat utility and therefore need to run on one of NERSC's Cray systems.  We will be using Hopper.  This is an introduction to profiling your code and is by no means comprehensive.  However, as we hopefully discussed during the study group, it's not always clear which parts of your code may be causing performance bottlenecks.  This is probably particularly true when making use of 3rd party software that may or may not be optimized.  In order to figure out where your pipelines are running into trouble, you can make use of profiling tools.  In this document I'll run through a brief example and then your assignment is to do some experiments on your own.  \\

I recommend using the code phyldog (bioinformatics related software) for this since it is an MPI code we have already built on Hopper, but feel free to build your own, just remember to move the executable to SCRATCH space before running your experiments.   

\section{Background}
 
 There are some basic steps for using CrayPat 
 \begin{enumerate}
 \item Load the perftools modulefile
 \item Build the application and keep the .o files
 \item Instrument the application using pat_build
 \item Run the instrumented executable to get a performance data file (".xf file")
 \item Run pat_report on the data file to view the results
 \end{enumerate}
 
 \subsection{Sampling}
Sampling (sometimes called "asynchronous") means the software will sample the program counter (PC) or the call stack at given time intervals or when specified counter overflows.  The program counter provides information about the state of your application at a given time

The program counter (PC), commonly called the instruction pointer (IP) in Intel x86 and Itanium microprocessors, and sometimes called the instruction address register (IAR)[1] or just part of the instruction sequencer,[2] is a processor register that indicates where a computer is in its program sequence.
In most processors, PC is incremented after fetching an instruction, and holds the memory address of (“points to”) the next instruction that would be executed. (In a processor where the incrementation precedes the fetch, PC points to the current instruction being executed.)

More information on how the CPU works can be found in any number of good textbooks and is beyond the scope of this homework assignment. 

The default experiment type is to sample the PC at a time interval (i.e., samp_pc_time). There are other sampling experiment types available.  The type can be set by the environment variable PAT_RT_EXPERIMENT (see the intro_craypat man page)
 
\subsection{Tracing}
Tracing Experiments

pat_build also can instrument an executable to trace calls to user-defined functions and Cray-provided library functions (e.g., MPI functions). Again, to generate an instrumented executable, one needs to load the perftools module first, and then compile and link the binary in separate steps.
 
\subsection{Automatic Program Analysis}
A sampling experiment runs with little overhead, but a detailed tracing experiment typically comes with large overhead, especially as you increase the number of nodes or cores used for the experiment.  Therefore, it's a good strategy to first run a sampling experiment to identify routines that would benefit from a full tracing experiment.  Once the routines are identified, the executable can be instrumented and the tracing experiments can be performed.  This should reduce the overall time needed to run the profiling experiments.  

CrayPat's Automatic Program Analysis (APA) feature provides an easy way to determine the routines that should be instrumented for a full trace.  The executable is instrumented for a sampling experiment and when the binary is executed, it generates an ASCII text file that contains CrayPat's suggestion for pat_build tracing options.  These options can be used to re-instrument the executable for detailed tracing experiments.

\section{Worked out example}
To give an idea of how this all works, we'll make use of the code in /usr/common/perftools.

\subsection{Serial example, sampling}

\subsection{MPI example}

\subsection{OpenMP example}

 
\section{Phyldog Experiment}
Please feel free to build whatever code you would like for the following experiments on Hopper.  

\end{document}